'use strict';
/*
 *   (c) Copyright 2018 Hewlett Packard Enterprise Development LP

 *   Licensed under the Apache License, Version 2.0 (the "License"); you may
 *   not use this file except in compliance with the License. You may obtain
 *   a copy of the License at

 *        http://www.apache.org/licenses/LICENSE-2.0

 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and limitations
 *   under the License.
 */

// if (typeof(WeakMap) === 'undefined') {
//     var WeakMap = require('weakmap');
// }

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _p = new WeakMap();
var caches = {};

var lruCache = (function () {
    function lruCache(cacheId, options) {
        _classCallCheck(this, lruCache);

        var privateProperties = {
            size: 0,
            stats: Object.assign({}, options, { id: cacheId }),
            data: {},
            capacity: options && options.capacity || Number.MAX_VALUE,
            lruHash: {},
            freshEnd: null,
            staleEnd: null
        };
        _p.set(this, privateProperties);
    }

    // TODO:
    _createClass(lruCache, [{
        key: 'put',
        value: function put(key, value) {
            var size, capacity, lruHash, data;
            if (value === undefined) {
                return;
            }
            size = _p.get(this).size;
            capacity = _p.get(this).capacity;
            lruHash = _p.get(this).lruHash;
            data = _p.get(this).data;

            if (capacity < Number.MAX_VALUE) {
                var lruEntry = lruHash[key] || (lruHash[key] = { key: key });
                this.__refresh(lruEntry);
            }
            if (!(key in data)) {
                _p.get(this).size = ++size;
            }

            data[key] = value;

            if (size > capacity) {
                this.remove(_p.get(this).staleEnd.key);
            }
            return value;
        }
    }, {
        key: 'get',
        value: function get(key) {
            var capacity = _p.get(this).capacity;

            if (capacity < Number.MAX_VALUE) {
                var lruEntry = _p.get(this).lruHash[key];
                if (!lruEntry) {
                    return;
                }
                this.__refresh(lruEntry);
            }

            return _p.get(this).data[key];
        }
    }, {
        key: 'remove',
        value: function remove(key) {
            var capacity = _p.get(this).capacity,
                size = _p.get(this).size,
                lruHash = _p.get(this).lruHash,
                data = _p.get(this).data;

            if (capacity < Number.MAX_VALUE) {
                var lruEntry = lruHash[key];

                if (!lruEntry) {
                    return;
                }

                if (lruEntry === _p.get(this).freshEnd) {
                    _p.get(this).freshEnd = lruEntry.p;
                }
                if (lruEntry === _p.get(this).staleEnd) {
                    _p.get(this).staleEnd = lruEntry.n;
                }
                this.__link(lruEntry.n, lruEntry.p);

                delete lruHash[key]; // Call by reference
            }

            delete data[key]; // Call by reference
            _p.get(this).size = --size;
        }
    }, {
        key: 'removeAll',
        value: function removeAll() {
            _p.get(this).data = {};
            _p.get(this).size = 0;
            _p.get(this).lruHash = {};
            _p.get(this).freshEnd = null;
            _p.get(this).staleEnd = null;
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            _p.get(this).data = null;
            _p.get(this).stats = null;
            _p.get(this).lruHash = null;
            delete caches[this.cacheId];
        }
    }, {
        key: 'info',
        value: function info() {
            return Object.assign({}, _p.get(this).stats, {
                size: _p.get(this).size
            });
        }
    }, {
        key: '__refresh',
        value: function __refresh(entry) {
            var freshEnd = _p.get(this).freshEnd,
                staleEnd = _p.get(this).staleEnd;

            if (entry !== freshEnd) {
                if (!staleEnd) {
                    _p.get(this).staleEnd = entry;
                } else if (staleEnd === entry) {
                    _p.get(this).staleEnd = entry.n;
                }

                this.__link(entry.n, entry.p);
                this.__link(entry, freshEnd);
                entry.n = null;
                _p.get(this).freshEnd = entry;
            }
        }
    }, {
        key: '__link',
        value: function __link(nextEntry, prevEntry) {
            if (nextEntry !== prevEntry) {
                if (nextEntry) {
                    nextEntry.p = prevEntry;
                }
                if (prevEntry) {
                    prevEntry.n = nextEntry;
                }
            }
        }
    }]);

    return lruCache;
})();

var fileCache = (function (_lruCache) {
    _inherits(fileCache, _lruCache);

    function fileCache(cacheId, options) {
        _classCallCheck(this, fileCache);

        _get(Object.getPrototypeOf(fileCache.prototype), 'constructor', this).call(this, cacheId, options);
    }

    return fileCache;
})(lruCache);

var cacheFactory = (function () {
    function cacheFactory() {
        _classCallCheck(this, cacheFactory);
    }

    _createClass(cacheFactory, null, [{
        key: 'get',
        value: function get(cacheId) {
            return caches[cacheId];
        }
    }, {
        key: 'create',
        value: function create(cacheId) {
            var options = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

            if (!(cacheId in caches)) {
                var type = options && options.type ? options.type : 'ramCache';
                caches[cacheId] = new this.mapping[type](cacheId, options);
                return caches[cacheId];
            }
            return;
        }
    }, {
        key: 'info',
        value: function info() {
            var info = {};

            for (var id in caches) {
                if (caches.hasOwnProperty(id)) {
                    info[id] = caches[id].info();
                }
            }
            return info;
        }
    }]);

    return cacheFactory;
})();

exports.cacheFactory = cacheFactory;

cacheFactory.RAMCACHE = 'ramCache';
cacheFactory.FILECACHE = 'fileCache';
cacheFactory.mapping = {
    ramCache: lruCache,
    fileCache: fileCache
};